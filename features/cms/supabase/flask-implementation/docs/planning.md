### Finalized Implementation Plan
Here's the full plan incorporating the directory structure, data formats (timestamp, id, content), per-user configs for hyperparameters (e.g., local storage row limit, FIFO eviction, etc.), plain HTML/CSS with minimal JS (only for client-side localStorage interactions since local data is device-based), and Supabase setup hand-holding. We'll use standard browser localStorage as a JSON array of rows for the local cache emulation.

updates: 
- Fully editable headers (no validation enforced, but code comments note path for future validation in the repo)
- default FIFO only (but modular/architected for future custom logic via client-side JS "upload" – risky for security but fitting for a developer-focused project)
- full user info display (raw from Supabase)
- auto-gen dummy but customizable, mock sample data. 
- Plan: Start with Google auth (easy via OAuth); for Claremont, test redirect behavior, possibly custom OAuth config with IT help, or suggest manual email linking for now. If CAS is SAML-only, it may require extra setup – we can implement a basic placeholder route for it later. Overall, dynamic configs, developer-focused (raw info exposure), and proof-of-concept with dummy data.

### Updated Long-Term Goals
- **Authentication**: Supabase Social Auth (Google + Claremont SSO). For future: enable linking multiple identities (e.g., Google account to SSO) per user; display linked providers on profile. Maybe have databases relative to identity? So you can log into multiple accounts and see all of the databases of both accounts. Ensure same user session regardless of provider.
- **User Configs**: Per-user settings for local cache (e.g., `{"headers": ["timestamp", "id", "content"], "eviction": {"method": "fifo", "enabled": true, "limit": 10}, "other_params": {}}`). Stored in Supabase per user device; client uses for rendering/display. Defaults: headers as specified, FIFO enabled, limit 10. Fully dynamic (config changes apply on refresh).
- **Local Cache ("temp database")**: Client-side localStorage (JSON array of rows matching user-config headers). FIFO eviction by default (replaceable with custom algo). Rows: `{"timestamp": "ISO-string", "id": autogenerated-uuid, "content": "text/markdown"}`. Enforce limit/eviction on add.
- **Remote Database**: Same row schema; CRUD via forms; storage via `content` field for markdown. Auto-filter by user.
- UI/UX: Server-rendered; plain HTML/CSS; minimal JS for localStorage interactions (pulls latest config from server-rendered template vars). Add dummy row button for proof-of-concept.
#### **Supabase Setup Hand-Holding** (Step-by-Step)
Since you have no existing project, I'll guide you through creation and configuration. This is based on the Flask quickstart docs – follow exactly.
#### 1. **Create Supabase Project & Account**
   - Go to [supabase.com/dashboard](https://supabase.com/dashboard); sign up/login.
   - Click "New Project": Set name (e.g., "Flask CMS"), secure DB password, pick region (e.g., US East).
   - Wait ~2-3 mins for setup; note project URL and keys (anon key for client-side operations).
#### 2. **Enable Auth Providers & Get Keys**
   - **Google OAuth**: Dashboard > Authentication > Providers > Google: Toggle on, set redirect URL to `http://localhost:3000/auth/callback` (or your Flask host/port).
   - **Claremont SSO Contingency**: If IT confirms OAuth support, add as "External OAuth" provider: Provide client ID, secret, auth/token endpoints from IT. Set same redirect URL. If not OAuth (e.g., SAML-only), note in code/docs: "CAS SSO requires SAML; implement via Supabase Enterprise or custom proxy later." Fallback: Skip for now, use manual account linking.
   - **API Keys**: Settings > API > Project URL (& anon key) → Save to `.env`: `SUPABASE_URL=<url>`, `SUPABASE_KEY=<anon-key>`. Add `SUPABASE_SERVICE_KEY=<service-role-key>` for server-side writes (optional but secure for admin tasks).
   - Ensure Row Level Security (RLS) is enabled globally.
#### 3. **Create Database Tables & Policies (SQL Editor)**
   - Run in Dashboard > SQL Editor to set up user-isolated data:
     ```
     -- Remote content table
     CREATE TABLE user_content (
       id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
       user_id UUID NOT NULL REFERENCES auth.users(id),
       timestamp TIMESTAMPTZ DEFAULT NOW(),
       content TEXT NOT NULL
     );
     ALTER TABLE user_content ENABLE ROW LEVEL SECURITY;
     CREATE POLICY "CRUD own content" ON user_content FOR ALL USING (auth.uid() = user_id);
     -- User configs (editable JSON)
     CREATE TABLE user_configs (
       user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
       config JSONB DEFAULT '{"headers": ["timestamp", "id", "content"], "eviction": {"method": "fifo", "enabled": true, "limit": 10}}'::jsonb
     );
     ALTER TABLE user_configs ENABLE ROW LEVEL SECURITY;
     CREATE POLICY "Manage own config" ON user_configs FOR ALL USING (auth.uid() = user_id);
     ```
   - (Optional) Insert sample data for testing: Replace `<test-user-id>` with a logged-in user's ID from Auth > Users.
     ```
     INSERT INTO user_content (user_id, content) VALUES
       ('<test-user-id>', '# Sample 1\nMarkdown content'),
       ('<test-user-id>', '# Sample 2\nMore text'),
       ('<test-user-id>', '# Sample 3\nTest data');
     ```
#### 4. **Install Supabase CLI (Optional for Local Testing)**
   - Run: `uv add supabase-cli` (or npm global install if preferred).
   - `supabase login`; `supabase init`; `supabase link --project-ref <project-id-from-dashboard>`.
   - Local development: `supabase start` for testing auth/tables (pushes changes).
#### 5. **Integrate into Flask App (Code Snippets Based on Docs)**
   - **Install Dependencies**: `uv add supabase python-dotenv sqlalchemy` (sqlalchemy for potential future UUID gen validation).
   - **.env File** (in project root):
     ```
     SUPABASE_URL=https://your-project.supabase.co
     SUPABASE_KEY=your-anon-key
     SUPABASE_SERVICE_KEY=your-service-key  # For server-side if needed
     ```
   - **App Init (`app/__init__.py`)**: Use your provided code for client creation with options (adjust timeouts as needed).
     ```python
     import os
     from supabase import create_client, Client
     from supabase.client import ClientOptions
     from flask import Flask
     from dotenv import load_dotenv
     
     load_dotenv()
     
     def create_app():
         app = Flask(__name__)
         app.secret_key = os.environ.get("SECRET_KEY", "dev-key")  # Add to .env
         
         # Supabase client with custom options (from your docs)
         url = os.environ.get("SUPABASE_URL")
         key = os.environ.get("SUPABASE_KEY")
         supabase: Client = create_client(
             url,
             key,
             options=ClientOptions(
                 postgrest_client_timeout=10,  # For API calls
                 storage_client_timeout=10,   # If using storage later
                 schema="public",
             )
         )
         app.supabase = supabase  # Attach to app for routes
         # Register blueprints (auth, dashboard, data)
         return app
     ```
   - **Auth Routes (`app/routes/auth.py` Example)**:
     - Use `sign_up` sparingly (for email/pass if adding later; your focus is OAuth).
     ```python
     @app.route('/login/google')
     def login_google():
         response = supabase.auth.sign_in_with_oauth(
             {
                 "provider": "google",
                 "options": {
                     "redirect_to": "http://localhost:3000/auth/callback"  # Matches Flask callback route
                 }
             }
         )
         return redirect(response.url)  # Redirects user to Google auth
     
     # /callback: Handle post-redirect, store session (details in auth.py impl)
     ```
     (For Claremont: If OAuth, swap "google" with custom provider name after setup. Redirect handles post-auth callback.)
   - **Testing**: Run a query in SQL Editor (e.g., `SELECT * FROM user_content WHERE user_id = auth.uid();` – should be filtered by RLS).
#### 6. **Fallback for Claremont SSO & Linking**
   - If no OAuth credentials: Implement manual linking in Flask (`/profile/link` route: User enters secondary email, associate via Supabase `auth.update_user({"email": new_email})` or custom merge logic (e.g., Supabase admin API to link users).
   - UI Note: "Link Accounts" section in profile template: Button for Google/Claremont; if Claremont not OAuth, show "Manual Email Link" form.
#### 7. **Next Steps Post-Setup**
   - Test login via Google; verify callback sets Flask session with `user = supabase.auth.user()`.
   - Check RLS: Logged-in users should only see their data.
   - If issues, use CLI commands like `supabase db reset` for schema tweaks.
   - Integrate into routes: Use `app.supabase` for queries (e.g., `supabase.table('user_content').select("*").execute()`).

#### Short-Term Execution Plan (Incremental Steps)
1. **Flask App Factory & Supabase Init (`app/__init__.py`)** (~10 mins)  
   - Define `create_app()`: Initialize Flask (secret key from `.env`), attach Supabase client using your snippets (with `ClientOptions` for timeouts/schema). Register blueprints for auth, dashboard, data, profile.  
   - No validation yet, but add comments: "Future: Validate user_configs JSON on edit (e.g., ensure 'headers' list not empty)".  
   - Outcome: Basic app structure ready for routes. Test: Run `uv run main.py` – app starts without errors.
2. **Authentication Routes (`app/routes/auth.py`)** (~30 mins)  
   - Implement `/login` (render HTML with Google login button: on click, use `sign_in_with_oauth` with redirect to `/callback`).  
   - Add `/callback` for OAuth flow: Handle redirect, parse tokens, store user in Flask session (including identities for profile). On first login, auto-insert default `user_configs` + 3 mock rows to `user_content` (use Supabase anon key).  
   - Placeholder for Claremont: Separate login button with manual linking (e.g., `/link-claremont`: Form for secondary email, merge accounts via email check).  
   - Protected decorator: `@login_required` for dashboard routes.  
   - Outcome: OAuth login works; users auto-get configs/data. Test: Login via Google → redirected to dashboard with session.
3. **Profile Routes & Template (`app/routes/profile.py`, `app/templates/profile.html`)** (~25 mins)  
   - New route: `/profile` (GET: Fetch Supabase `auth.user().identities` for raw JSON display; POST configs via form). Include linking section (Google button + manual email form for fallback).  
   - Template: Display identities as `<pre>` JSON (developer-focused); config edit form (textarea for JSONB string; updated on save). Note for Claremont: "SAML integration pending".  
   - Outcome: Users see full provider info + edit configs dynamically. Test: Visit /profile; update config → refresh dashboard applies.
4. **Data & Config Routes (`app/routes/data.py`, merge into `cache.py` placeholder)** (~40 mins)  
   - CRUD for remote: `/api/content` (GET list [filter by user], POST add row [auto-gen ID/timestamp], PUT update, DELETE with confirm). Use rows matching config.headers.  
   - Config endpoints: `/api/config` (GET/POST JSONB for editable settings). Add "eviction_logic" placeholder (string for future JS eval).  
   - Local cache: No routes (client-side), but JS in dashboard fetches config for rendering/eviction.  
   - Insert mock data on signup: 3 pre-gen rows `{timestamp: ISO now, id: uuid, content: "# Sample\n ipsum"}`.  
   - Outcome: Remote CRUD works; configs update instantly. Test: Add/edit rows via forms; verify user isolation.
5. **Dashboard Routes & Template Updates (`app/routes/dashboard.py`, `app/templates/dashboard.html`)** (~40 mins)  
   - Route: `/dashboard` (GET: Fetch user config + remote data; render template with vars for JS).  
   - Template: Dynamic table headers from config; two sections: Remote (CRUD forms + dummy add button [pre-filled customizable field]); Local (JS-rendered table, save/load from localStorage with FIFO eviction [vars from template]). JS: ~50 lines (no frameworks; includes config pull for headers/limit; comment for future eviction snippet).  
   - Remove protocol: Confirm dialog on delete (HTML form submit).  
   - Outcome: Functional UI for both databases. Test: Add dummy row; update local cache; verify eviction.
6. **Testing & Refinement (`tests/` placeholder)** (~20 mins)  
   - Run app: Login → Profile shows identities → Update config → Refresh dashboard applies → Add/remove rows → Local eviction works.  
   - Edge cases: Multiple providers (link via profile); config changes no reboot.  
   - If Claremont: Test manual linking.  
   - Outcome: Proof-of-concept ready. Add to `README.md`: Setup/install instructions.
#### Tradeoffs Noted
- **Local Storage & No JS**: Local brow wer data requires some JS (~50 lines max) for localStorage API – no way around without complex server-side proxy (e.g., saving to Flask session, but that's not "device-local"). Opted for minimal script block in template to keep it simple.
- **Data Formats**: Uniform `{timestamp, id, content}`; timestamp auto-generated via JS/Python.
- **Configs**: User-manageable in dedicated page; stored per-user in Supabase (editable anytime).
- **Security**: All routes protected; RLS enforces user isolation.
- **Scalability**: Start simple; future: Pagination for remote data, local SQLite if needed but user prefers device-local.
- **UI/UX**: Plain HTML/CSS for speed; if polish needed later, add Bootstrap.